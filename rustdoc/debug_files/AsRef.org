Trait AsRef

* Trait std::convert::AsRef

#+BEGIN_SRC rust 
pub trait AsRef<T> where
    T: ?Sized, {
    fn as_ref(&self) -> &T;
}
#+END_SRC

Used to do a cheap reference-to-reference conversion.

This trait is similar to =AsMut= which is used for converting between
mutable references. If you need to do a costly conversion it is better
to implement =From= with type =&T= or write a custom function.

=AsRef= has the same signature as =Borrow=, but =Borrow= is different in
few aspects:

- Unlike =AsRef=, =Borrow= has a blanket impl for any =T=, and can be
  used to accept either a reference or a value.
- =Borrow= also requires that =Hash=, =Eq= and =Ord= for borrowed value
  are equivalent to those of the owned value. For this reason, if you
  want to borrow only a single field of a struct you can implement
  =AsRef=, but not =Borrow=.

*Note: This trait must not fail*. If the conversion can fail, use a
dedicated method which returns an =Option<T>= or a =Result<T, E>=.

- =AsRef= auto-dereferences if the inner type is a reference or a
  mutable reference (e.g.: =foo.as_ref()= will work the same if =foo=
  has type =&mut Foo= or =&&mut Foo=)

By using trait bounds we can accept arguments of different types as long
as they can be converted to the specified type =T=.

For example: By creating a generic function that takes an =AsRef<str>=
we express that we want to accept all references that can be converted
to =&str= as an argument. Since both =String= and =&str= implement
=AsRef<str>= we can accept both as input argument.

#+BEGIN_SRC rust 
fn is_hello<T: AsRef<str>>(s: T) {
   assert_eq!("hello", s.as_ref());
}

let s = "hello";
is_hello(s);

let s = "hello".to_string();
is_hello(s);
#+END_SRC

* Required

*** = fn std::convert::AsRef::as_ref(&self) -> &T=

Performs the conversion.

* Implementors

** =impl AsRef<[u8]> for str=

=fn as_ref(&self) -> &[u8]= 

** =impl AsRef<[u8]> for String=

=fn as_ref(&self) -> &[u8]= 

** =impl AsRef<str> for str=

=fn as_ref(&self) -> &str= 

** =impl AsRef<str> for String=

=fn as_ref(&self) -> &str= 

** =impl AsRef<CStr> for CStr=

=fn as_ref(&self) -> &CStr= 

** =impl AsRef<CStr> for CString=

=fn as_ref(&self) -> &CStr= 

** =impl AsRef<OsStr> for str=

=fn as_ref(&self) -> &OsStr= 

** =impl AsRef<OsStr> for OsStr=

=fn as_ref(&self) -> &OsStr= 

** =impl AsRef<OsStr> for OsString=

=fn as_ref(&self) -> &OsStr= 

** =impl AsRef<OsStr> for Path=

=fn as_ref(&self) -> &OsStr= 

** =impl AsRef<OsStr> for PathBuf=

=fn as_ref(&self) -> &OsStr= 

** =impl AsRef<OsStr> for String=

=fn as_ref(&self) -> &OsStr= 

** =impl AsRef<Path> for str=

=fn as_ref(&self) -> &Path= 

** =impl AsRef<Path> for OsStr=

=fn as_ref(&self) -> &Path= 

** =impl AsRef<Path> for OsString=

=fn as_ref(&self) -> &Path= 

** =impl AsRef<Path> for Path=

=fn as_ref(&self) -> &Path= 

** =impl AsRef<Path> for PathBuf=

=fn as_ref(&self) -> &Path= 

** =impl AsRef<Path> for String=

=fn as_ref(&self) -> &Path= 

** =impl<'_> AsRef<OsStr> for Component<'_>=

=fn as_ref(&self) -> &OsStr= 

** =impl<'_> AsRef<OsStr> for Components<'_>=

=fn as_ref(&self) -> &OsStr= 

** =impl<'_> AsRef<OsStr> for std::path::Iter<'_>=

=fn as_ref(&self) -> &OsStr= 

** =impl<'_> AsRef<Path> for Cow<'_, OsStr>=

=fn as_ref(&self) -> &Path= 

** =impl<'_> AsRef<Path> for Component<'_>=

=fn as_ref(&self) -> &Path= 

** =impl<'_> AsRef<Path> for Components<'_>=

=fn as_ref(&self) -> &Path= 

** =impl<'_> AsRef<Path> for std::path::Iter<'_>=

=fn as_ref(&self) -> &Path= 

** =impl<'_, T> AsRef<[T]> for std::slice::Iter<'_, T>=

=fn as_ref(&self) -> &[T]= 

** =impl<'_, T> AsRef<T> for Cow<'_, T> where    T: ToOwned + ?Sized, =

=fn as_ref(&self) -> &T= 

** =impl<'_, T, U> AsRef<U> for &'_ T where    T: AsRef<U> + ?Sized,    U: ?Sized, =

=fn as_ref(&self) -> &U= 

** =impl<'_, T, U> AsRef<U> for &'_ mut T where    T: AsRef<U> + ?Sized,    U: ?Sized, =

=fn as_ref(&self) -> &U= 

** =impl<T> AsRef<[T]> for [T]=

=fn as_ref(&self) -> &[T]= 

** =impl<T> AsRef<[T]> for Vec<T>=

=fn as_ref(&self) -> &[T]= 

** =impl<T> AsRef<Vec<T>> for Vec<T>=

=fn as_ref(&self) -> &Vec<T>= 

** =impl<T> AsRef<T> for Box<T> where    T: ?Sized, =

=fn as_ref(&self) -> &T= 

** =impl<T> AsRef<T> for Rc<T> where    T: ?Sized, =

=fn as_ref(&self) -> &T= 

** =impl<T> AsRef<T> for Arc<T> where    T: ?Sized, =

=fn as_ref(&self) -> &T= 

** =impl<const N: usize, T> AsRef<[T]> for [T; N] where    [T; N]: LengthAtMost32, =

=fn as_ref(&self) -> &[T]= 
