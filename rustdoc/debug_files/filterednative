[Div ("",[],[])
 [Para [Str "Enum",Space,Str "Option"]
 ,Div ("",[],[])
  [Header 1 ("",[],[]) [Span ("",["in-band"],[]) [Str "Enum",Space,Span ("",[],[]) [Str "std"],Str "::",Span ("",[],[]) [Str "option"],Str "::",Span ("",[],[]) [Str "Option"]]]
  ,Div ("",[],[])
   [Para [Str "#+BEGIN_SRC rust \npub enum Option<T> {\n    None,\n    Some(T),\n}\n#+END_SRC"]]
  ,Div ("",[],[])
   [Para [Str "The",Space,Code ("",[],[]) "Option",Space,Str "type.",Space,Str "See",Space,Span ("",[],[]) [Str "the",Space,Str "module",Space,Str "level",Space,Str "documentation"],Space,Str "for",Space,Str "more."]]
  ,Header 1 ("",[],[]) [Str "Variants"]
  ,Header 2 ("",[],[]) [Code ("",[],[]) "None"]
  ,Div ("",[],[])
   [Para [Str "No",Space,Str "value"]]
  ,Header 2 ("",[],[]) [Code ("",[],[]) "Some(T)"]
  ,Div ("",[],[])
   [Para [Str "Some",Space,Str "value",Space,Code ("",[],[]) "T"]]
  ,Header 1 ("",[],[]) [Str "Implementations"]
  ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<T> Option<T>"]
  ,Div ("",[],[])
   [Header 3 ("",[],[]) [Code ("",[],[]) "pub fn is_some(&self) -> bool"]
   ,Plain [Str "if you intended to assert that this has a value, consider `.unwrap()` instead"]
   ,Div ("",[],[])
    [Para [Str "Returns",Space,Code ("",[],[]) "true",Space,Str "if",Space,Str "the",Space,Str "option",Space,Str "is",Space,Str "a",Space,Span ("",[],[]) [Code ("",[],[]) "Some"],Space,Str "value."]
    ,Div ("",[],[])
     [Para [Str "#+BEGIN_SRC rust \nlet x: Option<u32> = Some(2);\nassert_eq!(x.is_some(), true);\n\nlet x: Option<u32> = None;\nassert_eq!(x.is_some(), false);\n#+END_SRC"]]]
   ,Header 3 ("",[],[]) [Code ("",[],[]) "pub fn is_none(&self) -> bool"]
   ,Plain [Str "if you intended to assert that this doesn't have a value, consider \\                   `.and_then(|| panic!(\\\"`Option` had a value when expected `None`\\\"))` instead"]
   ,Div ("",[],[])
    [Para [Str "Returns",Space,Code ("",[],[]) "true",Space,Str "if",Space,Str "the",Space,Str "option",Space,Str "is",Space,Str "a",Space,Span ("",[],[]) [Code ("",[],[]) "None"],Space,Str "value."]
    ,Div ("",[],[])
     [Para [Str "#+BEGIN_SRC rust \nlet x: Option<u32> = Some(2);\nassert_eq!(x.is_none(), false);\n\nlet x: Option<u32> = None;\nassert_eq!(x.is_none(), true);\n#+END_SRC"]]]
   ,Header 3 ("",[],[]) [Code ("",[],[]) "pub fn contains<U>(&self, x: &U) -> bool where\160\160\160\160U: PartialEq<T>,\160"]
   ,Plain [Str ""]
   ,Div ("",[],[])
    [Div ("",[],[])
     [Plain [Space,Str "This",Space,Str "is",Space,Str "a",Space,Str "nightly-only",Space,Str "experimental",Space,Str "API.",Space,Str "(",Code ("",[],[]) "option_result_contains",Str "\160",Span ("",[],[]) [Str "#62358"],Str ")"]]]
   ,Div ("",[],[])
    [Para [Str "Returns",Space,Code ("",[],[]) "true",Space,Str "if",Space,Str "the",Space,Str "option",Space,Str "is",Space,Str "a",Space,Span ("",[],[]) [Code ("",[],[]) "Some"],Space,Str "value",Space,Str "containing",Space,Str "the",Space,Str "given",Space,Str "value."]
    ,Div ("",[],[])
     [Para [Str "#+BEGIN_SRC rust \n#![feature(option_result_contains)]\n\nlet x: Option<u32> = Some(2);\nassert_eq!(x.contains(&2), true);\n\nlet x: Option<u32> = Some(3);\nassert_eq!(x.contains(&2), false);\n\nlet x: Option<u32> = None;\nassert_eq!(x.contains(&2), false);\n#+END_SRC"]]]
   ,Header 3 ("",[],[]) [Code ("",[],[]) "pub fn as_ref(&self) -> Option<&T>"]
   ,Div ("",[],[])
    [Para [Str "Converts",Space,Str "from",Space,Code ("",[],[]) "&Option<T>",Space,Str "to",Space,Code ("",[],[]) "Option<&T>",Str "."]
    ,Para [Str "Converts",Space,Str "an",Space,Code ("",[],[]) "Option<",Span ("",[],[]) [Code ("",[],[]) "String"],Code ("",[],[]) ">",Space,Str "into",Space,Str "an",Space,Code ("",[],[]) "Option<",Span ("",[],[]) [Code ("",[],[]) "usize"],Code ("",[],[]) ">",Str ",",Space,Str "preserving",Space,Str "the",Space,Str "original.",SoftBreak,Str "The",Space,Span ("",[],[]) [Code ("",[],[]) "map"],Space,Str "method",Space,Str "takes",Space,Str "the",Space,Code ("",[],[]) "self",Space,Str "argument",Space,Str "by",Space,Str "value,",Space,Str "consuming",Space,Str "the",Space,Str "original,",SoftBreak,Str "so",Space,Str "this",Space,Str "technique",Space,Str "uses",Space,Code ("",[],[]) "as_ref",Space,Str "to",Space,Str "first",Space,Str "take",Space,Str "an",Space,Code ("",[],[]) "Option",Space,Str "to",Space,Str "a",Space,Str "reference",SoftBreak,Str "to",Space,Str "the",Space,Str "value",Space,Str "inside",Space,Str "the",Space,Str "original."]
    ,Div ("",[],[])
     [Para [Str "#+BEGIN_SRC rust \nlet text: Option<String> = Some(\"Hello, world!\".to_string());\n// First, cast `Option<String>` to `Option<&String>` with `as_ref`,\n// then consume *that* with `map`, leaving `text` on the stack.\nlet text_length: Option<usize> = text.as_ref().map(|s| s.len());\nprintln!(\"still can print text: {:?}\", text);\n#+END_SRC"]]]
   ,Header 3 ("",[],[]) [Code ("",[],[]) "pub fn as_mut(&mut self) -> Option<&mut T>"]
   ,Div ("",[],[])
    [Para [Str "Converts",Space,Str "from",Space,Code ("",[],[]) "&mut Option<T>",Space,Str "to",Space,Code ("",[],[]) "Option<&mut T>",Str "."]
    ,Div ("",[],[])
     [Para [Str "#+BEGIN_SRC rust \nlet mut x = Some(2);\nmatch x.as_mut() {\n    Some(v) => *v = 42,\n    None => {},\n}\nassert_eq!(x, Some(42));\n#+END_SRC"]]]
   ,Header 3 ("",[],[]) [Code ("",[],[]) "pub fn as_pin_ref(self: Pin<&Option<T>>) -> Option<Pin<&T>>"]
   ,Div ("",[],[])
    [Para [Str "Converts",Space,Str "from",Space,Span ("",[],[]) [Code ("",[],[]) "Pin"],Code ("",[],[]) "<&Option<T>>",Space,Str "to",Space,Code ("",[],[]) "Option<",Span ("",[],[]) [Code ("",[],[]) "Pin"],Code ("",[],[]) "<&T>>",Str "."]]
   ,Header 3 ("",[],[]) [Code ("",[],[]) "pub fn as_pin_mut(self: Pin<&mut Option<T>>) -> Option<Pin<&mut T>>"]
   ,Div ("",[],[])
    [Para [Str "Converts",Space,Str "from",Space,Span ("",[],[]) [Code ("",[],[]) "Pin"],Code ("",[],[]) "<&mut Option<T>>",Space,Str "to",Space,Code ("",[],[]) "Option<",Span ("",[],[]) [Code ("",[],[]) "Pin"],Code ("",[],[]) "<&mut T>>",Str "."]]
   ,Header 3 ("",[],[]) [Code ("",[],[]) "pub fn expect(self, msg: &str) -> T"]
   ,Div ("",[],[])
    [Para [Str "Returns",Space,Str "the",Space,Str "contained",Space,Span ("",[],[]) [Code ("",[],[]) "Some"],Space,Str "value,",Space,Str "consuming",Space,Str "the",Space,Code ("",[],[]) "self",Space,Str "value."]
    ,Para [Str "Panics",Space,Str "if",Space,Str "the",Space,Str "value",Space,Str "is",Space,Str "a",Space,Span ("",[],[]) [Code ("",[],[]) "None"],Space,Str "with",Space,Str "a",Space,Str "custom",Space,Str "panic",Space,Str "message",Space,Str "provided",Space,Str "by",SoftBreak,Code ("",[],[]) "msg",Str "."]
    ,Div ("",[],[])
     [Para [Str "#+BEGIN_SRC rust \nlet x = Some(\"value\");\nassert_eq!(x.expect(\"fruits are healthy\"), \"value\");\n#+END_SRC"]]
    ,Div ("",[],[])
     [Para [Str "#+BEGIN_SRC rust \nlet x: Option<&str> = None;\nx.expect(\"fruits are healthy\"); // panics with `fruits are healthy`\n#+END_SRC"]]]
   ,Header 3 ("",[],[]) [Code ("",[],[]) "pub fn unwrap(self) -> T"]
   ,Div ("",[],[])
    [Para [Str "Returns",Space,Str "the",Space,Str "contained",Space,Span ("",[],[]) [Code ("",[],[]) "Some"],Space,Str "value,",Space,Str "consuming",Space,Str "the",Space,Code ("",[],[]) "self",Space,Str "value."]
    ,Para [Str "Because",Space,Str "this",Space,Str "function",Space,Str "may",Space,Str "panic,",Space,Str "its",Space,Str "use",Space,Str "is",Space,Str "generally",Space,Str "discouraged.",SoftBreak,Str "Instead,",Space,Str "prefer",Space,Str "to",Space,Str "use",Space,Str "pattern",Space,Str "matching",Space,Str "and",Space,Str "handle",Space,Str "the",Space,Span ("",[],[]) [Code ("",[],[]) "None"],SoftBreak,Str "case",Space,Str "explicitly,",Space,Str "or",Space,Str "call",Space,Span ("",[],[]) [Code ("",[],[]) "unwrap_or"],Str ",",Space,Span ("",[],[]) [Code ("",[],[]) "unwrap_or_else"],Str ",",Space,Str "or",SoftBreak,Span ("",[],[]) [Code ("",[],[]) "unwrap_or_default"],Str "."]
    ,Para [Str "Panics",Space,Str "if",Space,Str "the",Space,Str "self",Space,Str "value",Space,Str "equals",Space,Span ("",[],[]) [Code ("",[],[]) "None"],Str "."]
    ,Div ("",[],[])
     [Para [Str "#+BEGIN_SRC rust \nlet x = Some(\"air\");\nassert_eq!(x.unwrap(), \"air\");\n#+END_SRC"]]
    ,Div ("",[],[])
     [Para [Str "#+BEGIN_SRC rust \nlet x: Option<&str> = None;\nassert_eq!(x.unwrap(), \"air\"); // fails\n#+END_SRC"]]]
   ,Header 3 ("",[],[]) [Code ("",[],[]) "pub fn unwrap_or(self, default: T) -> T"]
   ,Div ("",[],[])
    [Para [Str "Returns",Space,Str "the",Space,Str "contained",Space,Span ("",[],[]) [Code ("",[],[]) "Some"],Space,Str "value",Space,Str "or",Space,Str "a",Space,Str "provided",Space,Str "default."]
    ,Para [Str "Arguments",Space,Str "passed",Space,Str "to",Space,Code ("",[],[]) "unwrap_or",Space,Str "are",Space,Str "eagerly",Space,Str "evaluated;",Space,Str "if",Space,Str "you",Space,Str "are",Space,Str "passing",SoftBreak,Str "the",Space,Str "result",Space,Str "of",Space,Str "a",Space,Str "function",Space,Str "call,",Space,Str "it",Space,Str "is",Space,Str "recommended",Space,Str "to",Space,Str "use",Space,Span ("",[],[]) [Code ("",[],[]) "unwrap_or_else"],Str ",",SoftBreak,Str "which",Space,Str "is",Space,Str "lazily",Space,Str "evaluated."]
    ,Div ("",[],[])
     [Para [Str "#+BEGIN_SRC rust \nassert_eq!(Some(\"car\").unwrap_or(\"bike\"), \"car\");\nassert_eq!(None.unwrap_or(\"bike\"), \"bike\");\n#+END_SRC"]]]
   ,Header 3 ("",[],[]) [Code ("",[],[]) "pub fn unwrap_or_else<F>(self, f: F) -> T where\160\160\160\160F: FnOnce() -> T,\160"]
   ,Div ("",[],[])
    [Para [Str "Returns",Space,Str "the",Space,Str "contained",Space,Span ("",[],[]) [Code ("",[],[]) "Some"],Space,Str "value",Space,Str "or",Space,Str "computes",Space,Str "it",Space,Str "from",Space,Str "a",Space,Str "closure."]
    ,Div ("",[],[])
     [Para [Str "#+BEGIN_SRC rust \nlet k = 10;\nassert_eq!(Some(4).unwrap_or_else(|| 2 * k), 4);\nassert_eq!(None.unwrap_or_else(|| 2 * k), 20);\n#+END_SRC"]]]
   ,Header 3 ("",[],[]) [Code ("",[],[]) "pub fn map<U, F>(self, f: F) -> Option<U> where\160\160\160\160F: FnOnce(T) -> U,\160"]
   ,Div ("",[],[])
    [Para [Str "Maps",Space,Str "an",Space,Code ("",[],[]) "Option<T>",Space,Str "to",Space,Code ("",[],[]) "Option<U>",Space,Str "by",Space,Str "applying",Space,Str "a",Space,Str "function",Space,Str "to",Space,Str "a",Space,Str "contained",Space,Str "value."]
    ,Para [Str "Converts",Space,Str "an",Space,Code ("",[],[]) "Option<",Span ("",[],[]) [Code ("",[],[]) "String"],Code ("",[],[]) ">",Space,Str "into",Space,Str "an",Space,Code ("",[],[]) "Option<",Span ("",[],[]) [Code ("",[],[]) "usize"],Code ("",[],[]) ">",Str ",",Space,Str "consuming",Space,Str "the",Space,Str "original:"]
    ,Div ("",[],[])
     [Para [Str "#+BEGIN_SRC rust \nlet maybe_some_string = Some(String::from(\"Hello, World!\"));\n// `Option::map` takes self *by value*, consuming `maybe_some_string`\nlet maybe_some_len = maybe_some_string.map(|s| s.len());\n\nassert_eq!(maybe_some_len, Some(13));\n#+END_SRC"]]]
   ,Header 3 ("",[],[]) [Code ("",[],[]) "pub fn map_or<U, F>(self, default: U, f: F) -> U where\160\160\160\160F: FnOnce(T) -> U,\160"]
   ,Div ("",[],[])
    [Para [Str "Applies",Space,Str "a",Space,Str "function",Space,Str "to",Space,Str "the",Space,Str "contained",Space,Str "value",Space,Str "(if",Space,Str "any),",SoftBreak,Str "or",Space,Str "returns",Space,Str "the",Space,Str "provided",Space,Str "default",Space,Str "(if",Space,Str "not)."]
    ,Para [Str "Arguments",Space,Str "passed",Space,Str "to",Space,Code ("",[],[]) "map_or",Space,Str "are",Space,Str "eagerly",Space,Str "evaluated;",Space,Str "if",Space,Str "you",Space,Str "are",Space,Str "passing",SoftBreak,Str "the",Space,Str "result",Space,Str "of",Space,Str "a",Space,Str "function",Space,Str "call,",Space,Str "it",Space,Str "is",Space,Str "recommended",Space,Str "to",Space,Str "use",Space,Span ("",[],[]) [Code ("",[],[]) "map_or_else"],Str ",",SoftBreak,Str "which",Space,Str "is",Space,Str "lazily",Space,Str "evaluated."]
    ,Div ("",[],[])
     [Para [Str "#+BEGIN_SRC rust \nlet x = Some(\"foo\");\nassert_eq!(x.map_or(42, |v| v.len()), 3);\n\nlet x: Option<&str> = None;\nassert_eq!(x.map_or(42, |v| v.len()), 42);\n#+END_SRC"]]]
   ,Header 3 ("",[],[]) [Code ("",[],[]) "pub fn map_or_else<U, D, F>(self, default: D, f: F) -> U where\160\160\160\160D: FnOnce() -> U,\160\160\160\160F: FnOnce(T) -> U,\160"]
   ,Div ("",[],[])
    [Para [Str "Applies",Space,Str "a",Space,Str "function",Space,Str "to",Space,Str "the",Space,Str "contained",Space,Str "value",Space,Str "(if",Space,Str "any),",SoftBreak,Str "or",Space,Str "computes",Space,Str "a",Space,Str "default",Space,Str "(if",Space,Str "not)."]
    ,Div ("",[],[])
     [Para [Str "#+BEGIN_SRC rust \nlet k = 21;\n\nlet x = Some(\"foo\");\nassert_eq!(x.map_or_else(|| 2 * k, |v| v.len()), 3);\n\nlet x: Option<&str> = None;\nassert_eq!(x.map_or_else(|| 2 * k, |v| v.len()), 42);\n#+END_SRC"]]]
   ,Header 3 ("",[],[]) [Code ("",[],[]) "pub fn ok_or<E>(self, err: E) -> Result<T, E>"]
   ,Div ("",[],[])
    [Para [Str "Transforms",Space,Str "the",Space,Code ("",[],[]) "Option<T>",Space,Str "into",Space,Str "a",Space,Span ("",[],[]) [Code ("",[],[]) "Result<T, E>"],Str ",",Space,Str "mapping",Space,Span ("",[],[]) [Code ("",[],[]) "Some(v)"],Space,Str "to",SoftBreak,Span ("",[],[]) [Code ("",[],[]) "Ok(v)"],Space,Str "and",Space,Span ("",[],[]) [Code ("",[],[]) "None"],Space,Str "to",Space,Span ("",[],[]) [Code ("",[],[]) "Err(err)"],Str "."]
    ,Para [Str "Arguments",Space,Str "passed",Space,Str "to",Space,Code ("",[],[]) "ok_or",Space,Str "are",Space,Str "eagerly",Space,Str "evaluated;",Space,Str "if",Space,Str "you",Space,Str "are",Space,Str "passing",Space,Str "the",SoftBreak,Str "result",Space,Str "of",Space,Str "a",Space,Str "function",Space,Str "call,",Space,Str "it",Space,Str "is",Space,Str "recommended",Space,Str "to",Space,Str "use",Space,Span ("",[],[]) [Code ("",[],[]) "ok_or_else"],Str ",",Space,Str "which",Space,Str "is",SoftBreak,Str "lazily",Space,Str "evaluated."]
    ,Div ("",[],[])
     [Para [Str "#+BEGIN_SRC rust \nlet x = Some(\"foo\");\nassert_eq!(x.ok_or(0), Ok(\"foo\"));\n\nlet x: Option<&str> = None;\nassert_eq!(x.ok_or(0), Err(0));\n#+END_SRC"]]]
   ,Header 3 ("",[],[]) [Code ("",[],[]) "pub fn ok_or_else<E, F>(self, err: F) -> Result<T, E> where\160\160\160\160F: FnOnce() -> E,\160"]
   ,Div ("",[],[])
    [Para [Str "Transforms",Space,Str "the",Space,Code ("",[],[]) "Option<T>",Space,Str "into",Space,Str "a",Space,Span ("",[],[]) [Code ("",[],[]) "Result<T, E>"],Str ",",Space,Str "mapping",Space,Span ("",[],[]) [Code ("",[],[]) "Some(v)"],Space,Str "to",SoftBreak,Span ("",[],[]) [Code ("",[],[]) "Ok(v)"],Space,Str "and",Space,Span ("",[],[]) [Code ("",[],[]) "None"],Space,Str "to",Space,Span ("",[],[]) [Code ("",[],[]) "Err(err())"],Str "."]
    ,Div ("",[],[])
     [Para [Str "#+BEGIN_SRC rust \nlet x = Some(\"foo\");\nassert_eq!(x.ok_or_else(|| 0), Ok(\"foo\"));\n\nlet x: Option<&str> = None;\nassert_eq!(x.ok_or_else(|| 0), Err(0));\n#+END_SRC"]]]
   ,Header 3 ("",[],[]) [Code ("",[],[]) "pub fn iter(&self) -> Iter<T>"]
   ,Div ("",[],[])
    [Para [Str "Returns",Space,Str "an",Space,Str "iterator",Space,Str "over",Space,Str "the",Space,Str "possibly",Space,Str "contained",Space,Str "value."]
    ,Div ("",[],[])
     [Para [Str "#+BEGIN_SRC rust \nlet x = Some(4);\nassert_eq!(x.iter().next(), Some(&4));\n\nlet x: Option<u32> = None;\nassert_eq!(x.iter().next(), None);\n#+END_SRC"]]]
   ,Header 3 ("",[],[]) [Code ("",[],[]) "pub fn iter_mut(&mut self) -> IterMut<T>"]
   ,Div ("",[],[])
    [Para [Str "Returns",Space,Str "a",Space,Str "mutable",Space,Str "iterator",Space,Str "over",Space,Str "the",Space,Str "possibly",Space,Str "contained",Space,Str "value."]
    ,Div ("",[],[])
     [Para [Str "#+BEGIN_SRC rust \nlet mut x = Some(4);\nmatch x.iter_mut().next() {\n    Some(v) => *v = 42,\n    None => {},\n}\nassert_eq!(x, Some(42));\n\nlet mut x: Option<u32> = None;\nassert_eq!(x.iter_mut().next(), None);\n#+END_SRC"]]]
   ,Header 3 ("",[],[]) [Code ("",[],[]) "pub fn and<U>(self, optb: Option<U>) -> Option<U>"]
   ,Div ("",[],[])
    [Para [Str "Returns",Space,Span ("",[],[]) [Code ("",[],[]) "None"],Space,Str "if",Space,Str "the",Space,Str "option",Space,Str "is",Space,Span ("",[],[]) [Code ("",[],[]) "None"],Str ",",Space,Str "otherwise",Space,Str "returns",Space,Code ("",[],[]) "optb",Str "."]
    ,Div ("",[],[])
     [Para [Str "#+BEGIN_SRC rust \nlet x = Some(2);\nlet y: Option<&str> = None;\nassert_eq!(x.and(y), None);\n\nlet x: Option<u32> = None;\nlet y = Some(\"foo\");\nassert_eq!(x.and(y), None);\n\nlet x = Some(2);\nlet y = Some(\"foo\");\nassert_eq!(x.and(y), Some(\"foo\"));\n\nlet x: Option<u32> = None;\nlet y: Option<&str> = None;\nassert_eq!(x.and(y), None);\n#+END_SRC"]]]
   ,Header 3 ("",[],[]) [Code ("",[],[]) "pub fn and_then<U, F>(self, f: F) -> Option<U> where\160\160\160\160F: FnOnce(T) -> Option<U>,\160"]
   ,Div ("",[],[])
    [Para [Str "Returns",Space,Span ("",[],[]) [Code ("",[],[]) "None"],Space,Str "if",Space,Str "the",Space,Str "option",Space,Str "is",Space,Span ("",[],[]) [Code ("",[],[]) "None"],Str ",",Space,Str "otherwise",Space,Str "calls",Space,Code ("",[],[]) "f",Space,Str "with",Space,Str "the",SoftBreak,Str "wrapped",Space,Str "value",Space,Str "and",Space,Str "returns",Space,Str "the",Space,Str "result."]
    ,Para [Str "Some",Space,Str "languages",Space,Str "call",Space,Str "this",Space,Str "operation",Space,Str "flatmap."]
    ,Div ("",[],[])
     [Para [Str "#+BEGIN_SRC rust \nfn sq(x: u32) -> Option<u32> { Some(x * x) }\nfn nope(_: u32) -> Option<u32> { None }\n\nassert_eq!(Some(2).and_then(sq).and_then(sq), Some(16));\nassert_eq!(Some(2).and_then(sq).and_then(nope), None);\nassert_eq!(Some(2).and_then(nope).and_then(sq), None);\nassert_eq!(None.and_then(sq).and_then(sq), None);\n#+END_SRC"]]]
   ,Header 3 ("",[],[]) [Code ("",[],[]) "pub fn filter<P>(self, predicate: P) -> Option<T> where\160\160\160\160P: FnOnce(&T) -> bool,\160"]
   ,Div ("",[],[])
    [Para [Str "Returns",Space,Span ("",[],[]) [Code ("",[],[]) "None"],Space,Str "if",Space,Str "the",Space,Str "option",Space,Str "is",Space,Span ("",[],[]) [Code ("",[],[]) "None"],Str ",",Space,Str "otherwise",Space,Str "calls",Space,Code ("",[],[]) "predicate",SoftBreak,Str "with",Space,Str "the",Space,Str "wrapped",Space,Str "value",Space,Str "and",Space,Str "returns:"]
    ,BulletList
     [[Plain [Span ("",[],[]) [Code ("",[],[]) "Some(t)"],Space,Str "if",Space,Code ("",[],[]) "predicate",Space,Str "returns",Space,Code ("",[],[]) "true",Space,Str "(where",Space,Code ("",[],[]) "t",Space,Str "is",Space,Str "the",Space,Str "wrapped",SoftBreak,Str "value),",Space,Str "and"]]
     ,[Plain [Span ("",[],[]) [Code ("",[],[]) "None"],Space,Str "if",Space,Code ("",[],[]) "predicate",Space,Str "returns",Space,Code ("",[],[]) "false",Str "."]]]
    ,Para [Str "This",Space,Str "function",Space,Str "works",Space,Str "similar",Space,Str "to",Space,Span ("",[],[]) [Code ("",[],[]) "Iterator::filter()"],Str ".",Space,Str "You",Space,Str "can",Space,Str "imagine",SoftBreak,Str "the",Space,Code ("",[],[]) "Option<T>",Space,Str "being",Space,Str "an",Space,Str "iterator",Space,Str "over",Space,Str "one",Space,Str "or",Space,Str "zero",Space,Str "elements.",Space,Code ("",[],[]) "filter()",SoftBreak,Str "lets",Space,Str "you",Space,Str "decide",Space,Str "which",Space,Str "elements",Space,Str "to",Space,Str "keep."]
    ,Div ("",[],[])
     [Para [Str "#+BEGIN_SRC rust \nfn is_even(n: &i32) -> bool {\n    n % 2 == 0\n}\n\nassert_eq!(None.filter(is_even), None);\nassert_eq!(Some(3).filter(is_even), None);\nassert_eq!(Some(4).filter(is_even), Some(4));\n#+END_SRC"]]]
   ,Header 3 ("",[],[]) [Code ("",[],[]) "pub fn or(self, optb: Option<T>) -> Option<T>"]
   ,Div ("",[],[])
    [Para [Str "Returns",Space,Str "the",Space,Str "option",Space,Str "if",Space,Str "it",Space,Str "contains",Space,Str "a",Space,Str "value,",Space,Str "otherwise",Space,Str "returns",Space,Code ("",[],[]) "optb",Str "."]
    ,Para [Str "Arguments",Space,Str "passed",Space,Str "to",Space,Code ("",[],[]) "or",Space,Str "are",Space,Str "eagerly",Space,Str "evaluated;",Space,Str "if",Space,Str "you",Space,Str "are",Space,Str "passing",Space,Str "the",SoftBreak,Str "result",Space,Str "of",Space,Str "a",Space,Str "function",Space,Str "call,",Space,Str "it",Space,Str "is",Space,Str "recommended",Space,Str "to",Space,Str "use",Space,Span ("",[],[]) [Code ("",[],[]) "or_else"],Str ",",Space,Str "which",Space,Str "is",SoftBreak,Str "lazily",Space,Str "evaluated."]
    ,Div ("",[],[])
     [Para [Str "#+BEGIN_SRC rust \nlet x = Some(2);\nlet y = None;\nassert_eq!(x.or(y), Some(2));\n\nlet x = None;\nlet y = Some(100);\nassert_eq!(x.or(y), Some(100));\n\nlet x = Some(2);\nlet y = Some(100);\nassert_eq!(x.or(y), Some(2));\n\nlet x: Option<u32> = None;\nlet y = None;\nassert_eq!(x.or(y), None);\n#+END_SRC"]]]
   ,Header 3 ("",[],[]) [Code ("",[],[]) "pub fn or_else<F>(self, f: F) -> Option<T> where\160\160\160\160F: FnOnce() -> Option<T>,\160"]
   ,Div ("",[],[])
    [Para [Str "Returns",Space,Str "the",Space,Str "option",Space,Str "if",Space,Str "it",Space,Str "contains",Space,Str "a",Space,Str "value,",Space,Str "otherwise",Space,Str "calls",Space,Code ("",[],[]) "f",Space,Str "and",SoftBreak,Str "returns",Space,Str "the",Space,Str "result."]
    ,Div ("",[],[])
     [Para [Str "#+BEGIN_SRC rust \nfn nobody() -> Option<&'static str> { None }\nfn vikings() -> Option<&'static str> { Some(\"vikings\") }\n\nassert_eq!(Some(\"barbarians\").or_else(vikings), Some(\"barbarians\"));\nassert_eq!(None.or_else(vikings), Some(\"vikings\"));\nassert_eq!(None.or_else(nobody), None);\n#+END_SRC"]]]
   ,Header 3 ("",[],[]) [Code ("",[],[]) "pub fn xor(self, optb: Option<T>) -> Option<T>"]
   ,Div ("",[],[])
    [Para [Str "Returns",Space,Span ("",[],[]) [Code ("",[],[]) "Some"],Space,Str "if",Space,Str "exactly",Space,Str "one",Space,Str "of",Space,Code ("",[],[]) "self",Str ",",Space,Code ("",[],[]) "optb",Space,Str "is",Space,Span ("",[],[]) [Code ("",[],[]) "Some"],Str ",",Space,Str "otherwise",Space,Str "returns",Space,Span ("",[],[]) [Code ("",[],[]) "None"],Str "."]
    ,Div ("",[],[])
     [Para [Str "#+BEGIN_SRC rust \nlet x = Some(2);\nlet y: Option<u32> = None;\nassert_eq!(x.xor(y), Some(2));\n\nlet x: Option<u32> = None;\nlet y = Some(2);\nassert_eq!(x.xor(y), Some(2));\n\nlet x = Some(2);\nlet y = Some(2);\nassert_eq!(x.xor(y), None);\n\nlet x: Option<u32> = None;\nlet y: Option<u32> = None;\nassert_eq!(x.xor(y), None);\n#+END_SRC"]]]
   ,Header 3 ("",[],[]) [Code ("",[],[]) "pub fn get_or_insert(&mut self, v: T) -> &mut T"]
   ,Div ("",[],[])
    [Para [Str "Inserts",Space,Code ("",[],[]) "v",Space,Str "into",Space,Str "the",Space,Str "option",Space,Str "if",Space,Str "it",Space,Str "is",Space,Span ("",[],[]) [Code ("",[],[]) "None"],Str ",",Space,Str "then",SoftBreak,Str "returns",Space,Str "a",Space,Str "mutable",Space,Str "reference",Space,Str "to",Space,Str "the",Space,Str "contained",Space,Str "value."]
    ,Div ("",[],[])
     [Para [Str "#+BEGIN_SRC rust \nlet mut x = None;\n\n{\n    let y: &mut u32 = x.get_or_insert(5);\n    assert_eq!(y, &5);\n\n    *y = 7;\n}\n\nassert_eq!(x, Some(7));\n#+END_SRC"]]]
   ,Header 3 ("",[],[]) [Code ("",[],[]) "pub fn get_or_insert_with<F>(&mut self, f: F) -> &mut T where\160\160\160\160F: FnOnce() -> T,\160"]
   ,Div ("",[],[])
    [Para [Str "Inserts",Space,Str "a",Space,Str "value",Space,Str "computed",Space,Str "from",Space,Code ("",[],[]) "f",Space,Str "into",Space,Str "the",Space,Str "option",Space,Str "if",Space,Str "it",Space,Str "is",Space,Span ("",[],[]) [Code ("",[],[]) "None"],Str ",",Space,Str "then",SoftBreak,Str "returns",Space,Str "a",Space,Str "mutable",Space,Str "reference",Space,Str "to",Space,Str "the",Space,Str "contained",Space,Str "value."]
    ,Div ("",[],[])
     [Para [Str "#+BEGIN_SRC rust \nlet mut x = None;\n\n{\n    let y: &mut u32 = x.get_or_insert_with(|| 5);\n    assert_eq!(y, &5);\n\n    *y = 7;\n}\n\nassert_eq!(x, Some(7));\n#+END_SRC"]]]
   ,Header 3 ("",[],[]) [Code ("",[],[]) "pub fn take(&mut self) -> Option<T>"]
   ,Div ("",[],[])
    [Para [Str "Takes",Space,Str "the",Space,Str "value",Space,Str "out",Space,Str "of",Space,Str "the",Space,Str "option,",Space,Str "leaving",Space,Str "a",Space,Span ("",[],[]) [Code ("",[],[]) "None"],Space,Str "in",Space,Str "its",Space,Str "place."]
    ,Div ("",[],[])
     [Para [Str "#+BEGIN_SRC rust \nlet mut x = Some(2);\nlet y = x.take();\nassert_eq!(x, None);\nassert_eq!(y, Some(2));\n\nlet mut x: Option<u32> = None;\nlet y = x.take();\nassert_eq!(x, None);\nassert_eq!(y, None);\n#+END_SRC"]]]
   ,Header 3 ("",[],[]) [Code ("",[],[]) "pub fn replace(&mut self, value: T) -> Option<T>"]
   ,Div ("",[],[])
    [Para [Str "Replaces",Space,Str "the",Space,Str "actual",Space,Str "value",Space,Str "in",Space,Str "the",Space,Str "option",Space,Str "by",Space,Str "the",Space,Str "value",Space,Str "given",Space,Str "in",Space,Str "parameter,",SoftBreak,Str "returning",Space,Str "the",Space,Str "old",Space,Str "value",Space,Str "if",Space,Str "present,",SoftBreak,Str "leaving",Space,Str "a",Space,Span ("",[],[]) [Code ("",[],[]) "Some"],Space,Str "in",Space,Str "its",Space,Str "place",Space,Str "without",Space,Str "deinitializing",Space,Str "either",Space,Str "one."]
    ,Div ("",[],[])
     [Para [Str "#+BEGIN_SRC rust \nlet mut x = Some(2);\nlet old = x.replace(5);\nassert_eq!(x, Some(5));\nassert_eq!(old, Some(2));\n\nlet mut x = None;\nlet old = x.replace(3);\nassert_eq!(x, Some(3));\nassert_eq!(old, None);\n#+END_SRC"]]]
   ,Header 3 ("",[],[]) [Code ("",[],[]) "pub fn zip<U>(self, other: Option<U>) -> Option<(T, U)>"]
   ,Div ("",[],[])
    [Div ("",[],[])
     [Plain [Space,Str "This",Space,Str "is",Space,Str "a",Space,Str "nightly-only",Space,Str "experimental",Space,Str "API.",Space,Str "(",Code ("",[],[]) "option_zip",Str "\160",Span ("",[],[]) [Str "#70086"],Str ")"]]]
   ,Div ("",[],[])
    [Para [Str "Zips",Space,Code ("",[],[]) "self",Space,Str "with",Space,Str "another",Space,Code ("",[],[]) "Option",Str "."]
    ,Para [Str "If",Space,Code ("",[],[]) "self",Space,Str "is",Space,Code ("",[],[]) "Some(s)",Space,Str "and",Space,Code ("",[],[]) "other",Space,Str "is",Space,Code ("",[],[]) "Some(o)",Str ",",Space,Str "this",Space,Str "method",Space,Str "returns",Space,Code ("",[],[]) "Some((s, o))",Str ".",SoftBreak,Str "Otherwise,",Space,Code ("",[],[]) "None",Space,Str "is",Space,Str "returned."]
    ,Div ("",[],[])
     [Para [Str "#+BEGIN_SRC rust \n#![feature(option_zip)]\nlet x = Some(1);\nlet y = Some(\"hi\");\nlet z = None::<u8>;\n\nassert_eq!(x.zip(y), Some((1, \"hi\")));\nassert_eq!(x.zip(z), None);\n#+END_SRC"]]]
   ,Header 3 ("",[],[]) [Code ("",[],[]) "pub fn zip_with<U, F, R>(self, other: Option<U>, f: F) -> Option<R> where\160\160\160\160F: FnOnce(T, U) -> R,\160"]
   ,Div ("",[],[])
    [Div ("",[],[])
     [Plain [Space,Str "This",Space,Str "is",Space,Str "a",Space,Str "nightly-only",Space,Str "experimental",Space,Str "API.",Space,Str "(",Code ("",[],[]) "option_zip",Str "\160",Span ("",[],[]) [Str "#70086"],Str ")"]]]
   ,Div ("",[],[])
    [Para [Str "Zips",Space,Code ("",[],[]) "self",Space,Str "and",Space,Str "another",Space,Code ("",[],[]) "Option",Space,Str "with",Space,Str "function",Space,Code ("",[],[]) "f",Str "."]
    ,Para [Str "If",Space,Code ("",[],[]) "self",Space,Str "is",Space,Code ("",[],[]) "Some(s)",Space,Str "and",Space,Code ("",[],[]) "other",Space,Str "is",Space,Code ("",[],[]) "Some(o)",Str ",",Space,Str "this",Space,Str "method",Space,Str "returns",Space,Code ("",[],[]) "Some(f(s, o))",Str ".",SoftBreak,Str "Otherwise,",Space,Code ("",[],[]) "None",Space,Str "is",Space,Str "returned."]
    ,Div ("",[],[])
     [Para [Str "#+BEGIN_SRC rust \n#![feature(option_zip)]\n\n#[derive(Debug, PartialEq)]\nstruct Point {\n    x: f64,\n    y: f64,\n}\n\nimpl Point {\n    fn new(x: f64, y: f64) -> Self {\n        Self { x, y }\n    }\n}\n\nlet x = Some(17.5);\nlet y = Some(42.7);\n\nassert_eq!(x.zip_with(y, Point::new), Some(Point { x: 17.5, y: 42.7 }));\nassert_eq!(x.zip_with(None, Point::new), None);\n#+END_SRC"]]]]
  ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<'_, T> Option<&'_ T> where\160\160\160\160T: Copy,\160"]
  ,Div ("",[],[])
   [Header 3 ("",[],[]) [Code ("",[],[]) "pub fn copied(self) -> Option<T>"]
   ,Div ("",[],[])
    [Para [Str "Maps",Space,Str "an",Space,Code ("",[],[]) "Option<&T>",Space,Str "to",Space,Str "an",Space,Code ("",[],[]) "Option<T>",Space,Str "by",Space,Str "copying",Space,Str "the",Space,Str "contents",Space,Str "of",Space,Str "the",SoftBreak,Str "option."]
    ,Div ("",[],[])
     [Para [Str "#+BEGIN_SRC rust \nlet x = 12;\nlet opt_x = Some(&x);\nassert_eq!(opt_x, Some(&12));\nlet copied = opt_x.copied();\nassert_eq!(copied, Some(12));\n#+END_SRC"]]]]
  ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<'_, T> Option<&'_ mut T> where\160\160\160\160T: Copy,\160"]
  ,Div ("",[],[])
   [Header 3 ("",[],[]) [Code ("",[],[]) "pub fn copied(self) -> Option<T>"]
   ,Div ("",[],[])
    [Para [Str "Maps",Space,Str "an",Space,Code ("",[],[]) "Option<&mut T>",Space,Str "to",Space,Str "an",Space,Code ("",[],[]) "Option<T>",Space,Str "by",Space,Str "copying",Space,Str "the",Space,Str "contents",Space,Str "of",Space,Str "the",SoftBreak,Str "option."]
    ,Div ("",[],[])
     [Para [Str "#+BEGIN_SRC rust \nlet mut x = 12;\nlet opt_x = Some(&mut x);\nassert_eq!(opt_x, Some(&mut 12));\nlet copied = opt_x.copied();\nassert_eq!(copied, Some(12));\n#+END_SRC"]]]]
  ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<'_, T> Option<&'_ T> where\160\160\160\160T: Clone,\160"]
  ,Div ("",[],[])
   [Header 3 ("",[],[]) [Code ("",[],[]) "pub fn cloned(self) -> Option<T>"]
   ,Div ("",[],[])
    [Para [Str "Maps",Space,Str "an",Space,Code ("",[],[]) "Option<&T>",Space,Str "to",Space,Str "an",Space,Code ("",[],[]) "Option<T>",Space,Str "by",Space,Str "cloning",Space,Str "the",Space,Str "contents",Space,Str "of",Space,Str "the",SoftBreak,Str "option."]
    ,Div ("",[],[])
     [Para [Str "#+BEGIN_SRC rust \nlet x = 12;\nlet opt_x = Some(&x);\nassert_eq!(opt_x, Some(&12));\nlet cloned = opt_x.cloned();\nassert_eq!(cloned, Some(12));\n#+END_SRC"]]]]
  ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<'_, T> Option<&'_ mut T> where\160\160\160\160T: Clone,\160"]
  ,Div ("",[],[])
   [Header 3 ("",[],[]) [Code ("",[],[]) "pub fn cloned(self) -> Option<T>"]
   ,Div ("",[],[])
    [Para [Str "Maps",Space,Str "an",Space,Code ("",[],[]) "Option<&mut T>",Space,Str "to",Space,Str "an",Space,Code ("",[],[]) "Option<T>",Space,Str "by",Space,Str "cloning",Space,Str "the",Space,Str "contents",Space,Str "of",Space,Str "the",SoftBreak,Str "option."]
    ,Div ("",[],[])
     [Para [Str "#+BEGIN_SRC rust \nlet mut x = 12;\nlet opt_x = Some(&mut x);\nassert_eq!(opt_x, Some(&mut 12));\nlet cloned = opt_x.cloned();\nassert_eq!(cloned, Some(12));\n#+END_SRC"]]]]
  ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<T> Option<T> where\160\160\160\160T: Debug,\160"]
  ,Div ("",[],[])
   [Header 3 ("",[],[]) [Code ("",[],[]) "pub fn expect_none(self, msg: &str)"]
   ,Div ("",[],[])
    [Div ("",[],[])
     [Plain [Space,Str "This",Space,Str "is",Space,Str "a",Space,Str "nightly-only",Space,Str "experimental",Space,Str "API.",Space,Str "(",Code ("",[],[]) "option_expect_none",Str "\160",Span ("",[],[]) [Str "#62633"],Str ")"]
     ,Para [Str "newly",Space,Str "added"]]]
   ,Div ("",[],[])
    [Para [Str "Consumes",Space,Code ("",[],[]) "self",Space,Str "while",Space,Str "expecting",Space,Span ("",[],[]) [Code ("",[],[]) "None"],Space,Str "and",Space,Str "returning",Space,Str "nothing."]
    ,Para [Str "Panics",Space,Str "if",Space,Str "the",Space,Str "value",Space,Str "is",Space,Str "a",Space,Span ("",[],[]) [Code ("",[],[]) "Some"],Str ",",Space,Str "with",Space,Str "a",Space,Str "panic",Space,Str "message",Space,Str "including",Space,Str "the",SoftBreak,Str "passed",Space,Str "message,",Space,Str "and",Space,Str "the",Space,Str "content",Space,Str "of",Space,Str "the",Space,Span ("",[],[]) [Code ("",[],[]) "Some"],Str "."]
    ,Div ("",[],[])
     [Para [Str "#+BEGIN_SRC rust \n#![feature(option_expect_none)]\n\nuse std::collections::HashMap;\nlet mut squares = HashMap::new();\nfor i in -10..=10 {\n    // This will not panic, since all keys are unique.\n    squares.insert(i, i * i).expect_none(\"duplicate key\");\n}\n#+END_SRC"]]
    ,Div ("",[],[])
     [Para [Str "#+BEGIN_SRC rust \n#![feature(option_expect_none)]\n\nuse std::collections::HashMap;\nlet mut sqrts = HashMap::new();\nfor i in -10..=10 {\n    // This will panic, since both negative and positive `i` will\n    // insert the same `i * i` key, returning the old `Some(i)`.\n    sqrts.insert(i * i, i).expect_none(\"duplicate key\");\n}\n#+END_SRC"]]]
   ,Header 3 ("",[],[]) [Code ("",[],[]) "pub fn unwrap_none(self)"]
   ,Div ("",[],[])
    [Div ("",[],[])
     [Plain [Space,Str "This",Space,Str "is",Space,Str "a",Space,Str "nightly-only",Space,Str "experimental",Space,Str "API.",Space,Str "(",Code ("",[],[]) "option_unwrap_none",Str "\160",Span ("",[],[]) [Str "#62633"],Str ")"]
     ,Para [Str "newly",Space,Str "added"]]]
   ,Div ("",[],[])
    [Para [Str "Consumes",Space,Code ("",[],[]) "self",Space,Str "while",Space,Str "expecting",Space,Span ("",[],[]) [Code ("",[],[]) "None"],Space,Str "and",Space,Str "returning",Space,Str "nothing."]
    ,Para [Str "Panics",Space,Str "if",Space,Str "the",Space,Str "value",Space,Str "is",Space,Str "a",Space,Span ("",[],[]) [Code ("",[],[]) "Some"],Str ",",Space,Str "with",Space,Str "a",Space,Str "custom",Space,Str "panic",Space,Str "message",Space,Str "provided",SoftBreak,Str "by",Space,Str "the",Space,Span ("",[],[]) [Code ("",[],[]) "Some"],Str "'s",Space,Str "value."]
    ,Div ("",[],[])
     [Para [Str "#+BEGIN_SRC rust \n#![feature(option_unwrap_none)]\n\nuse std::collections::HashMap;\nlet mut squares = HashMap::new();\nfor i in -10..=10 {\n    // This will not panic, since all keys are unique.\n    squares.insert(i, i * i).unwrap_none();\n}\n#+END_SRC"]]
    ,Div ("",[],[])
     [Para [Str "#+BEGIN_SRC rust \n#![feature(option_unwrap_none)]\n\nuse std::collections::HashMap;\nlet mut sqrts = HashMap::new();\nfor i in -10..=10 {\n    // This will panic, since both negative and positive `i` will\n    // insert the same `i * i` key, returning the old `Some(i)`.\n    sqrts.insert(i * i, i).unwrap_none();\n}\n#+END_SRC"]]]]
  ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<T> Option<T> where\160\160\160\160T: Default,\160"]
  ,Div ("",[],[])
   [Header 3 ("",[],[]) [Code ("",[],[]) "pub fn unwrap_or_default(self) -> T"]
   ,Div ("",[],[])
    [Para [Str "Returns",Space,Str "the",Space,Str "contained",Space,Span ("",[],[]) [Code ("",[],[]) "Some"],Space,Str "value",Space,Str "or",Space,Str "a",Space,Str "default"]
    ,Para [Str "Consumes",Space,Str "the",Space,Code ("",[],[]) "self",Space,Str "argument",Space,Str "then,",Space,Str "if",Space,Span ("",[],[]) [Code ("",[],[]) "Some"],Str ",",Space,Str "returns",Space,Str "the",Space,Str "contained",SoftBreak,Str "value,",Space,Str "otherwise",Space,Str "if",Space,Span ("",[],[]) [Code ("",[],[]) "None"],Str ",",Space,Str "returns",Space,Str "the",Space,Span ("",[],[]) [Str "default",Space,Str "value"],Space,Str "for",Space,Str "that",SoftBreak,Str "type."]
    ,Para [Str "Converts",Space,Str "a",Space,Str "string",Space,Str "to",Space,Str "an",Space,Str "integer,",Space,Str "turning",Space,Str "poorly-formed",Space,Str "strings",SoftBreak,Str "into",Space,Str "0",Space,Str "(the",Space,Str "default",Space,Str "value",Space,Str "for",Space,Str "integers).",Space,Span ("",[],[]) [Code ("",[],[]) "parse"],Space,Str "converts",SoftBreak,Str "a",Space,Str "string",Space,Str "to",Space,Str "any",Space,Str "other",Space,Str "type",Space,Str "that",Space,Str "implements",Space,Span ("",[],[]) [Code ("",[],[]) "FromStr"],Str ",",Space,Str "returning",SoftBreak,Span ("",[],[]) [Code ("",[],[]) "None"],Space,Str "on",Space,Str "error."]
    ,Div ("",[],[])
     [Para [Str "#+BEGIN_SRC rust \nlet good_year_from_input = \"1909\";\nlet bad_year_from_input = \"190blarg\";\nlet good_year = good_year_from_input.parse().ok().unwrap_or_default();\nlet bad_year = bad_year_from_input.parse().ok().unwrap_or_default();\n\nassert_eq!(1909, good_year);\nassert_eq!(0, bad_year);\n#+END_SRC"]]]]
  ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<T> Option<T> where\160\160\160\160T: Deref,\160"]
  ,Div ("",[],[])
   [Header 3 ("",[],[]) [Code ("",[],[]) "pub fn as_deref(&self) -> Option<&<T as Deref>::Target>"]
   ,Div ("",[],[])
    [Para [Str "Converts",Space,Str "from",Space,Code ("",[],[]) "Option<T>",Space,Str "(or",Space,Code ("",[],[]) "&Option<T>",Str ")",Space,Str "to",Space,Code ("",[],[]) "Option<&T::Target>",Str "."]
    ,Para [Str "Leaves",Space,Str "the",Space,Str "original",Space,Str "Option",Space,Str "in-place,",Space,Str "creating",Space,Str "a",Space,Str "new",Space,Str "one",Space,Str "with",Space,Str "a",Space,Str "reference",SoftBreak,Str "to",Space,Str "the",Space,Str "original",Space,Str "one,",Space,Str "additionally",Space,Str "coercing",Space,Str "the",Space,Str "contents",Space,Str "via",Space,Span ("",[],[]) [Code ("",[],[]) "Deref"],Str "."]
    ,Div ("",[],[])
     [Para [Str "#+BEGIN_SRC rust \nlet x: Option<String> = Some(\"hey\".to_owned());\nassert_eq!(x.as_deref(), Some(\"hey\"));\n\nlet x: Option<String> = None;\nassert_eq!(x.as_deref(), None);\n#+END_SRC"]]]]
  ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<T> Option<T> where\160\160\160\160T: DerefMut,\160"]
  ,Div ("",[],[])
   [Header 3 ("",[],[]) [Code ("",[],[]) "pub fn as_deref_mut(&mut self) -> Option<&mut <T as Deref>::Target>"]
   ,Div ("",[],[])
    [Para [Str "Converts",Space,Str "from",Space,Code ("",[],[]) "Option<T>",Space,Str "(or",Space,Code ("",[],[]) "&mut Option<T>",Str ")",Space,Str "to",Space,Code ("",[],[]) "Option<&mut T::Target>",Str "."]
    ,Para [Str "Leaves",Space,Str "the",Space,Str "original",Space,Code ("",[],[]) "Option",Space,Str "in-place,",Space,Str "creating",Space,Str "a",Space,Str "new",Space,Str "one",Space,Str "containing",Space,Str "a",Space,Str "mutable",Space,Str "reference",Space,Str "to",SoftBreak,Str "the",Space,Str "inner",Space,Str "type's",Space,Code ("",[],[]) "Deref::Target",Space,Str "type."]
    ,Div ("",[],[])
     [Para [Str "#+BEGIN_SRC rust \nlet mut x: Option<String> = Some(\"hey\".to_owned());\nassert_eq!(x.as_deref_mut().map(|x| {\n    x.make_ascii_uppercase();\n    x\n}), Some(\"HEY\".to_owned().as_mut_str()));\n#+END_SRC"]]]]
  ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<T, E> Option<Result<T, E>>"]
  ,Div ("",[],[])
   [Header 3 ("",[],[]) [Code ("",[],[]) "pub fn transpose(self) -> Result<Option<T>, E>"]
   ,Div ("",[],[])
    [Para [Str "Transposes",Space,Str "an",Space,Code ("",[],[]) "Option",Space,Str "of",Space,Str "a",Space,Span ("",[],[]) [Code ("",[],[]) "Result"],Space,Str "into",Space,Str "a",Space,Span ("",[],[]) [Code ("",[],[]) "Result"],Space,Str "of",Space,Str "an",Space,Code ("",[],[]) "Option",Str "."]
    ,Para [Span ("",[],[]) [Code ("",[],[]) "None"],Space,Str "will",Space,Str "be",Space,Str "mapped",Space,Str "to",Space,Span ("",[],[]) [Code ("",[],[]) "Ok"],Code ("",[],[]) "(",Span ("",[],[]) [Code ("",[],[]) "None"],Code ("",[],[]) ")",Str ".",SoftBreak,Span ("",[],[]) [Code ("",[],[]) "Some"],Code ("",[],[]) "(",Span ("",[],[]) [Code ("",[],[]) "Ok"],Code ("",[],[]) "(_))",Space,Str "and",Space,Span ("",[],[]) [Code ("",[],[]) "Some"],Code ("",[],[]) "(",Span ("",[],[]) [Code ("",[],[]) "Err"],Code ("",[],[]) "(_))",Space,Str "will",Space,Str "be",Space,Str "mapped",Space,Str "to",SoftBreak,Span ("",[],[]) [Code ("",[],[]) "Ok"],Code ("",[],[]) "(",Span ("",[],[]) [Code ("",[],[]) "Some"],Code ("",[],[]) "(_))",Space,Str "and",Space,Span ("",[],[]) [Code ("",[],[]) "Err"],Code ("",[],[]) "(_)",Str "."]
    ,Div ("",[],[])
     [Para [Str "#+BEGIN_SRC rust \n#[derive(Debug, Eq, PartialEq)]\nstruct SomeErr;\n\nlet x: Result<Option<i32>, SomeErr> = Ok(Some(5));\nlet y: Option<Result<i32, SomeErr>> = Some(Ok(5));\nassert_eq!(x, y.transpose());\n#+END_SRC"]]]]
  ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<T> Option<Option<T>>"]
  ,Div ("",[],[])
   [Header 3 ("",[],[]) [Code ("",[],[]) "pub fn flatten(self) -> Option<T>"]
   ,Div ("",[],[])
    [Para [Str "Converts",Space,Str "from",Space,Code ("",[],[]) "Option<Option<T>>",Space,Str "to",Space,Code ("",[],[]) "Option<T>"]
    ,Para [Str "Basic",Space,Str "usage:"]
    ,Div ("",[],[])
     [Para [Str "#+BEGIN_SRC rust \nlet x: Option<Option<u32>> = Some(Some(6));\nassert_eq!(Some(6), x.flatten());\n\nlet x: Option<Option<u32>> = Some(None);\nassert_eq!(None, x.flatten());\n\nlet x: Option<Option<u32>> = None;\nassert_eq!(None, x.flatten());\n#+END_SRC"]]
    ,Para [Str "Flattening",Space,Str "once",Space,Str "only",Space,Str "removes",Space,Str "one",Space,Str "level",Space,Str "of",Space,Str "nesting:"]
    ,Div ("",[],[])
     [Para [Str "#+BEGIN_SRC rust \nlet x: Option<Option<Option<u32>>> = Some(Some(Some(6)));\nassert_eq!(Some(Some(6)), x.flatten());\nassert_eq!(Some(6), x.flatten().flatten());\n#+END_SRC"]]]]
  ,Header 1 ("",[],[]) [Str "Trait"]
  ,Div ("",[],[])
   [Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<T> Clone for Option<T> where\160\160\160\160T: Clone,\160"]
   ,Div ("",[],[])
    [Plain [Code ("clone.v",[],[]) "fn clone(&self) -> Option<T>",Span ("",[],[]) [Str " "]]
    ,Div ("",[],[])
     [Para [Str "Returns",Space,Str "a",Space,Str "copy",Space,Str "of",Space,Str "the",Space,Str "value.",Space,Span ("",[],[]) [Str "Read",Space,Str "more"]]]
    ,Plain [Code ("clone_from.v",[],[]) "fn clone_from(&mut self, source: &Option<T>)",Span ("",[],[]) [Str " "]]
    ,Div ("",[],[])
     [Para [Str "Performs",Space,Str "copy-assignment",Space,Str "from",Space,Code ("",[],[]) "source",Str ".",Space,Span ("",[],[]) [Str "Read",Space,Str "more"]]]]
   ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<T> Copy for Option<T> where\160\160\160\160T: Copy,\160"]
   ,Div ("",[],[])
    []
   ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<T> Debug for Option<T> where\160\160\160\160T: Debug,\160"]
   ,Div ("",[],[])
    [Plain [Code ("fmt.v",[],[]) "fn fmt(&self, f: &mut Formatter) -> Result<(), Error>",Span ("",[],[]) [Str " "]]
    ,Div ("",[],[])
     [Para [Str "Formats",Space,Str "the",Space,Str "value",Space,Str "using",Space,Str "the",Space,Str "given",Space,Str "formatter.",Space,Span ("",[],[]) [Str "Read",Space,Str "more"]]]]
   ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<T> Default for Option<T>"]
   ,Div ("",[],[])
    [Header 3 ("",[],[]) [Code ("",[],[]) "fn default() -> Option<T>"]
    ,Div ("",[],[])
     [Para [Str "Returns",Space,Span ("",[],[]) [Code ("",[],[]) "None"],Str "."]
     ,Div ("",[],[])
      [Para [Str "#+BEGIN_SRC rust \nlet opt: Option<u32> = Option::default();\nassert!(opt.is_none());\n#+END_SRC"]]]]
   ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<T> Eq for Option<T> where\160\160\160\160T: Eq,\160"]
   ,Div ("",[],[])
    []
   ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<'a, T> From<&'a Option<T>> for Option<&'a T>"]
   ,Div ("",[],[])
    [Header 3 ("",[],[]) [Code ("",[],[]) "fn from(o: &'a Option<T>) -> Option<&'a T>"]
    ,Div ("",[],[])
     [Para [Str "Converts",Space,Str "from",Space,Code ("",[],[]) "&Option<T>",Space,Str "to",Space,Code ("",[],[]) "Option<&T>",Str "."]
     ,Para [Str "Converts",Space,Str "an",Space,Code ("",[],[]) "Option<",Span ("",[],[]) [Code ("",[],[]) "String"],Code ("",[],[]) ">",Space,Str "into",Space,Str "an",Space,Code ("",[],[]) "Option<",Span ("",[],[]) [Code ("",[],[]) "usize"],Code ("",[],[]) ">",Str ",",Space,Str "preserving",Space,Str "the",Space,Str "original.",SoftBreak,Str "The",Space,Span ("",[],[]) [Code ("",[],[]) "map"],Space,Str "method",Space,Str "takes",Space,Str "the",Space,Code ("",[],[]) "self",Space,Str "argument",Space,Str "by",Space,Str "value,",Space,Str "consuming",Space,Str "the",Space,Str "original,",SoftBreak,Str "so",Space,Str "this",Space,Str "technique",Space,Str "uses",Space,Code ("",[],[]) "as_ref",Space,Str "to",Space,Str "first",Space,Str "take",Space,Str "an",Space,Code ("",[],[]) "Option",Space,Str "to",Space,Str "a",Space,Str "reference",SoftBreak,Str "to",Space,Str "the",Space,Str "value",Space,Str "inside",Space,Str "the",Space,Str "original."]
     ,Div ("",[],[])
      [Para [Str "#+BEGIN_SRC rust \nlet s: Option<String> = Some(String::from(\"Hello, Rustaceans!\"));\nlet o: Option<usize> = Option::from(&s).map(|ss: &String| ss.len());\n\nprintln!(\"Can still print s: {:?}\", s);\n\nassert_eq!(o, Some(18));\n#+END_SRC"]]]]
   ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<'a, T> From<&'a mut Option<T>> for Option<&'a mut T>"]
   ,Div ("",[],[])
    [Header 3 ("",[],[]) [Code ("",[],[]) "fn from(o: &'a mut Option<T>) -> Option<&'a mut T>"]
    ,Div ("",[],[])
     [Para [Str "Converts",Space,Str "from",Space,Code ("",[],[]) "&mut Option<T>",Space,Str "to",Space,Code ("",[],[]) "Option<&mut T>"]
     ,Div ("",[],[])
      [Para [Str "#+BEGIN_SRC rust \nlet mut s = Some(String::from(\"Hello\"));\nlet o: Option<&mut String> = Option::from(&mut s);\n\nmatch o {\n    Some(t) => *t = String::from(\"Hello, Rustaceans!\"),\n    None => (),\n}\n\nassert_eq!(s, Some(String::from(\"Hello, Rustaceans!\")));\n#+END_SRC"]]]]
   ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<T> From<T> for Option<T>"]
   ,Div ("",[],[])
    [Header 3 ("",[],[]) [Code ("",[],[]) "fn from(val: T) -> Option<T>"]
    ,Div ("",[],[])
     [Para [Str "Copies",Space,Code ("",[],[]) "val",Space,Str "into",Space,Str "a",Space,Str "new",Space,Code ("",[],[]) "Some",Str "."]
     ,Div ("",[],[])
      [Para [Str "#+BEGIN_SRC rust \nlet o: Option<u8> = Option::from(67);\n\nassert_eq!(Some(67), o);\n#+END_SRC"]]]]
   ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<A, V> FromIterator<Option<A>> for Option<V> where\160\160\160\160V: FromIterator<A>,\160"]
   ,Div ("",[],[])
    [Header 3 ("",[],[]) [Code ("",[],[]) "fn from_iter<I>(iter: I) -> Option<V> where\160\160\160\160I: IntoIterator<Item = Option<A>>,\160"]
    ,Div ("",[],[])
     [Para [Str "Takes",Space,Str "each",Space,Str "element",Space,Str "in",Space,Str "the",Space,Span ("",[],[]) [Code ("",[],[]) "Iterator"],Str ":",Space,Str "if",Space,Str "it",Space,Str "is",Space,Span ("",[],[]) [Code ("",[],[]) "None"],Str ",",SoftBreak,Str "no",Space,Str "further",Space,Str "elements",Space,Str "are",Space,Str "taken,",Space,Str "and",Space,Str "the",Space,Span ("",[],[]) [Code ("",[],[]) "None"],Space,Str "is",SoftBreak,Str "returned.",Space,Str "Should",Space,Str "no",Space,Span ("",[],[]) [Code ("",[],[]) "None"],Space,Str "occur,",Space,Str "a",Space,Str "container",Space,Str "with",Space,Str "the",SoftBreak,Str "values",Space,Str "of",Space,Str "each",Space,Span ("",[],[]) [Code ("",[],[]) "Option"],Space,Str "is",Space,Str "returned."]
     ,Para [Str "Here",Space,Str "is",Space,Str "an",Space,Str "example",Space,Str "which",Space,Str "increments",Space,Str "every",Space,Str "integer",Space,Str "in",Space,Str "a",Space,Str "vector.",SoftBreak,Str "We",Space,Str "use",Space,Str "the",Space,Str "checked",Space,Str "variant",Space,Str "of",Space,Code ("",[],[]) "add",Space,Str "that",Space,Str "returns",Space,Code ("",[],[]) "None",Space,Str "when",Space,Str "the",SoftBreak,Str "calculation",Space,Str "would",Space,Str "result",Space,Str "in",Space,Str "an",Space,Str "overflow."]
     ,Div ("",[],[])
      [Para [Str "#+BEGIN_SRC rust \nlet items = vec![0_u16, 1, 2];\n\nlet res: Option<Vec<u16>> = items\n    .iter()\n    .map(|x| x.checked_add(1))\n    .collect();\n\nassert_eq!(res, Some(vec![1, 2, 3]));\n#+END_SRC"]]
     ,Para [Str "As",Space,Str "you",Space,Str "can",Space,Str "see,",Space,Str "this",Space,Str "will",Space,Str "return",Space,Str "the",Space,Str "expected,",Space,Str "valid",Space,Str "items."]
     ,Para [Str "Here",Space,Str "is",Space,Str "another",Space,Str "example",Space,Str "that",Space,Str "tries",Space,Str "to",Space,Str "subtract",Space,Str "one",Space,Str "from",Space,Str "another",Space,Str "list",SoftBreak,Str "of",Space,Str "integers,",Space,Str "this",Space,Str "time",Space,Str "checking",Space,Str "for",Space,Str "underflow:"]
     ,Div ("",[],[])
      [Para [Str "#+BEGIN_SRC rust \nlet items = vec![2_u16, 1, 0];\n\nlet res: Option<Vec<u16>> = items\n    .iter()\n    .map(|x| x.checked_sub(1))\n    .collect();\n\nassert_eq!(res, None);\n#+END_SRC"]]
     ,Para [Str "Since",Space,Str "the",Space,Str "last",Space,Str "element",Space,Str "is",Space,Str "zero,",Space,Str "it",Space,Str "would",Space,Str "underflow.",Space,Str "Thus,",Space,Str "the",Space,Str "resulting",SoftBreak,Str "value",Space,Str "is",Space,Code ("",[],[]) "None",Str "."]
     ,Para [Str "Here",Space,Str "is",Space,Str "a",Space,Str "variation",Space,Str "on",Space,Str "the",Space,Str "previous",Space,Str "example,",Space,Str "showing",Space,Str "that",Space,Str "no",SoftBreak,Str "further",Space,Str "elements",Space,Str "are",Space,Str "taken",Space,Str "from",Space,Code ("",[],[]) "iter",Space,Str "after",Space,Str "the",Space,Str "first",Space,Code ("",[],[]) "None",Str "."]
     ,Div ("",[],[])
      [Para [Str "#+BEGIN_SRC rust \nlet items = vec![3_u16, 2, 1, 10];\n\nlet mut shared = 0;\n\nlet res: Option<Vec<u16>> = items\n    .iter()\n    .map(|x| { shared += x; x.checked_sub(2) })\n    .collect();\n\nassert_eq!(res, None);\nassert_eq!(shared, 6);\n#+END_SRC"]]
     ,Para [Str "Since",Space,Str "the",Space,Str "third",Space,Str "element",Space,Str "caused",Space,Str "an",Space,Str "underflow,",Space,Str "no",Space,Str "further",Space,Str "elements",Space,Str "were",Space,Str "taken,",SoftBreak,Str "so",Space,Str "the",Space,Str "final",Space,Str "value",Space,Str "of",Space,Code ("",[],[]) "shared",Space,Str "is",Space,Str "6",Space,Str "(=",Space,Code ("",[],[]) "3 + 2 + 1",Str "),",Space,Str "not",Space,Str "16."]]]
   ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<T> Hash for Option<T> where\160\160\160\160T: Hash,\160"]
   ,Div ("",[],[])
    [Plain [Code ("hash.v",[],[]) "fn hash<__H>(&self, state: &mut __H) where\160\160\160\160__H: Hasher,\160",Span ("",[],[]) [Str " "]]
    ,Div ("",[],[])
     [Para [Str "Feeds",Space,Str "this",Space,Str "value",Space,Str "into",Space,Str "the",Space,Str "given",Space,Str "[",Code ("",[],[]) "Hasher",Str "].",Space,Span ("",[],[]) [Str "Read",Space,Str "more"]]]
    ,Plain [Code ("hash_slice.v",[],[]) "fn hash_slice<H>(data: &[Self], state: &mut H) where\160\160\160\160H: Hasher,\160",Span ("",[],[]) [Str " "]]
    ,Div ("",[],[])
     [Para [Str "Feeds",Space,Str "a",Space,Str "slice",Space,Str "of",Space,Str "this",Space,Str "type",Space,Str "into",Space,Str "the",Space,Str "given",Space,Str "[",Code ("",[],[]) "Hasher",Str "].",Space,Span ("",[],[]) [Str "Read",Space,Str "more"]]]]
   ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<T> IntoIterator for Option<T>"]
   ,Div ("",[],[])
    [Header 3 ("",[],[]) [Code ("Item.t",[],[]) "type Item = T"]
    ,Div ("",[],[])
     [Para [Str "The",Space,Str "type",Space,Str "of",Space,Str "the",Space,Str "elements",Space,Str "being",Space,Str "iterated",Space,Str "over."]]
    ,Header 3 ("",[],[]) [Code ("IntoIter.t",[],[]) "type IntoIter = IntoIter<T>"]
    ,Div ("",[],[])
     [Para [Str "Which",Space,Str "kind",Space,Str "of",Space,Str "iterator",Space,Str "are",Space,Str "we",Space,Str "turning",Space,Str "this",Space,Str "into?"]]
    ,Header 3 ("",[],[]) [Code ("",[],[]) "fn into_iter(self) -> IntoIter<T>"]
    ,Div ("",[],[])
     [Para [Str "Returns",Space,Str "a",Space,Str "consuming",Space,Str "iterator",Space,Str "over",Space,Str "the",Space,Str "possibly",Space,Str "contained",Space,Str "value."]
     ,Div ("",[],[])
      [Para [Str "#+BEGIN_SRC rust \nlet x = Some(\"string\");\nlet v: Vec<&str> = x.into_iter().collect();\nassert_eq!(v, [\"string\"]);\n\nlet x = None;\nlet v: Vec<&str> = x.into_iter().collect();\nassert!(v.is_empty());\n#+END_SRC"]]]]
   ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<'a, T> IntoIterator for &'a Option<T>"]
   ,Div ("",[],[])
    [Header 3 ("",[],[]) [Code ("Item.t-1",[],[]) "type Item = &'a T"]
    ,Div ("",[],[])
     [Para [Str "The",Space,Str "type",Space,Str "of",Space,Str "the",Space,Str "elements",Space,Str "being",Space,Str "iterated",Space,Str "over."]]
    ,Header 3 ("",[],[]) [Code ("IntoIter.t-1",[],[]) "type IntoIter = Iter<'a, T>"]
    ,Div ("",[],[])
     [Para [Str "Which",Space,Str "kind",Space,Str "of",Space,Str "iterator",Space,Str "are",Space,Str "we",Space,Str "turning",Space,Str "this",Space,Str "into?"]]
    ,Plain [Code ("into_iter.v-1",[],[]) "fn into_iter(self) -> Iter<'a, T>",Span ("",[],[]) [Str " "]]
    ,Div ("",[],[])
     [Para [Str "Creates",Space,Str "an",Space,Str "iterator",Space,Str "from",Space,Str "a",Space,Str "value.",Space,Span ("",[],[]) [Str "Read",Space,Str "more"]]]]
   ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<'a, T> IntoIterator for &'a mut Option<T>"]
   ,Div ("",[],[])
    [Header 3 ("",[],[]) [Code ("Item.t-2",[],[]) "type Item = &'a mut T"]
    ,Div ("",[],[])
     [Para [Str "The",Space,Str "type",Space,Str "of",Space,Str "the",Space,Str "elements",Space,Str "being",Space,Str "iterated",Space,Str "over."]]
    ,Header 3 ("",[],[]) [Code ("IntoIter.t-2",[],[]) "type IntoIter = IterMut<'a, T>"]
    ,Div ("",[],[])
     [Para [Str "Which",Space,Str "kind",Space,Str "of",Space,Str "iterator",Space,Str "are",Space,Str "we",Space,Str "turning",Space,Str "this",Space,Str "into?"]]
    ,Plain [Code ("into_iter.v-2",[],[]) "fn into_iter(self) -> IterMut<'a, T>",Span ("",[],[]) [Str " "]]
    ,Div ("",[],[])
     [Para [Str "Creates",Space,Str "an",Space,Str "iterator",Space,Str "from",Space,Str "a",Space,Str "value.",Space,Span ("",[],[]) [Str "Read",Space,Str "more"]]]]
   ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<T> Ord for Option<T> where\160\160\160\160T: Ord,\160"]
   ,Div ("",[],[])
    [Plain [Code ("cmp.v",[],[]) "fn cmp(&self, other: &Option<T>) -> Ordering",Span ("",[],[]) [Str " "]]
    ,Div ("",[],[])
     [Para [Str "This",Space,Str "method",Space,Str "returns",Space,Str "an",Space,Str "[",Code ("",[],[]) "Ordering",Str "]",Space,Str "between",Space,Code ("",[],[]) "self",Space,Str "and",Space,Code ("",[],[]) "other",Str ".",Space,Span ("",[],[]) [Str "Read",Space,Str "more"]]]
    ,Plain [Code ("max.v",[],[]) "#[must_use]fn max(self, other: Self) -> Self",Span ("",[],[]) [Str " "]]
    ,Div ("",[],[])
     [Para [Str "Compares",Space,Str "and",Space,Str "returns",Space,Str "the",Space,Str "maximum",Space,Str "of",Space,Str "two",Space,Str "values.",Space,Span ("",[],[]) [Str "Read",Space,Str "more"]]]
    ,Plain [Code ("min.v",[],[]) "#[must_use]fn min(self, other: Self) -> Self",Span ("",[],[]) [Str " "]]
    ,Div ("",[],[])
     [Para [Str "Compares",Space,Str "and",Space,Str "returns",Space,Str "the",Space,Str "minimum",Space,Str "of",Space,Str "two",Space,Str "values.",Space,Span ("",[],[]) [Str "Read",Space,Str "more"]]]
    ,Plain [Code ("clamp.v",[],[]) "#[must_use]fn clamp(self, min: Self, max: Self) -> Self",Span ("",[],[]) [Str " "]]
    ,Div ("",[],[])
     [Div ("",[],[])
      [Plain [Space,Str "This",Space,Str "is",Space,Str "a",Space,Str "nightly-only",Space,Str "experimental",Space,Str "API.",Space,Str "(",Code ("",[],[]) "clamp",Str "\160",Span ("",[],[]) [Str "#44095"],Str ")"]]]
    ,Div ("",[],[])
     [Para [Str "Restrict",Space,Str "a",Space,Str "value",Space,Str "to",Space,Str "a",Space,Str "certain",Space,Str "interval.",Space,Span ("",[],[]) [Str "Read",Space,Str "more"]]]]
   ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<T> PartialEq<Option<T>> for Option<T> where\160\160\160\160T: PartialEq<T>,\160"]
   ,Div ("",[],[])
    [Plain [Code ("eq.v",[],[]) "fn eq(&self, other: &Option<T>) -> bool",Span ("",[],[]) [Str " "]]
    ,Div ("",[],[])
     [Para [Str "This",Space,Str "method",Space,Str "tests",Space,Str "for",Space,Code ("",[],[]) "self",Space,Str "and",Space,Code ("",[],[]) "other",Space,Str "values",Space,Str "to",Space,Str "be",Space,Str "equal,",Space,Str "and",Space,Str "is",Space,Str "used",Space,Str "by",Space,Code ("",[],[]) "==",Str ".",Space,Span ("",[],[]) [Str "Read",Space,Str "more"]]]
    ,Plain [Code ("ne.v",[],[]) "fn ne(&self, other: &Option<T>) -> bool",Span ("",[],[]) [Str " "]]
    ,Div ("",[],[])
     [Para [Str "This",Space,Str "method",Space,Str "tests",Space,Str "for",Space,Code ("",[],[]) "!=",Str "."]]]
   ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<T> PartialOrd<Option<T>> for Option<T> where\160\160\160\160T: PartialOrd<T>,\160"]
   ,Div ("",[],[])
    [Plain [Code ("partial_cmp.v",[],[]) "fn partial_cmp(&self, other: &Option<T>) -> Option<Ordering>",Span ("",[],[]) [Str " "]]
    ,Div ("",[],[])
     [Para [Str "This",Space,Str "method",Space,Str "returns",Space,Str "an",Space,Str "ordering",Space,Str "between",Space,Code ("",[],[]) "self",Space,Str "and",Space,Code ("",[],[]) "other",Space,Str "values",Space,Str "if",Space,Str "one",Space,Str "exists.",Space,Span ("",[],[]) [Str "Read",Space,Str "more"]]]
    ,Plain [Code ("lt.v",[],[]) "fn lt(&self, other: &Option<T>) -> bool",Span ("",[],[]) [Str " "]]
    ,Div ("",[],[])
     [Para [Str "This",Space,Str "method",Space,Str "tests",Space,Str "less",Space,Str "than",Space,Str "(for",Space,Code ("",[],[]) "self",Space,Str "and",Space,Code ("",[],[]) "other",Str ")",Space,Str "and",Space,Str "is",Space,Str "used",Space,Str "by",Space,Str "the",Space,Code ("",[],[]) "<",Space,Str "operator.",Space,Span ("",[],[]) [Str "Read",Space,Str "more"]]]
    ,Plain [Code ("le.v",[],[]) "fn le(&self, other: &Option<T>) -> bool",Span ("",[],[]) [Str " "]]
    ,Div ("",[],[])
     [Para [Str "This",Space,Str "method",Space,Str "tests",Space,Str "less",Space,Str "than",Space,Str "or",Space,Str "equal",Space,Str "to",Space,Str "(for",Space,Code ("",[],[]) "self",Space,Str "and",Space,Code ("",[],[]) "other",Str ")",Space,Str "and",Space,Str "is",Space,Str "used",Space,Str "by",Space,Str "the",Space,Code ("",[],[]) "<=",Space,Str "operator.",Space,Span ("",[],[]) [Str "Read",Space,Str "more"]]]
    ,Plain [Code ("gt.v",[],[]) "fn gt(&self, other: &Option<T>) -> bool",Span ("",[],[]) [Str " "]]
    ,Div ("",[],[])
     [Para [Str "This",Space,Str "method",Space,Str "tests",Space,Str "greater",Space,Str "than",Space,Str "(for",Space,Code ("",[],[]) "self",Space,Str "and",Space,Code ("",[],[]) "other",Str ")",Space,Str "and",Space,Str "is",Space,Str "used",Space,Str "by",Space,Str "the",Space,Code ("",[],[]) ">",Space,Str "operator.",Space,Span ("",[],[]) [Str "Read",Space,Str "more"]]]
    ,Plain [Code ("ge.v",[],[]) "fn ge(&self, other: &Option<T>) -> bool",Span ("",[],[]) [Str " "]]
    ,Div ("",[],[])
     [Para [Str "This",Space,Str "method",Space,Str "tests",Space,Str "greater",Space,Str "than",Space,Str "or",Space,Str "equal",Space,Str "to",Space,Str "(for",Space,Code ("",[],[]) "self",Space,Str "and",Space,Code ("",[],[]) "other",Str ")",Space,Str "and",Space,Str "is",Space,Str "used",Space,Str "by",Space,Str "the",Space,Code ("",[],[]) ">=",Space,Str "operator.",Space,Span ("",[],[]) [Str "Read",Space,Str "more"]]]]
   ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<T, U> Product<Option<U>> for Option<T> where\160\160\160\160T: Product<U>,\160"]
   ,Div ("",[],[])
    [Header 3 ("",[],[]) [Code ("",[],[]) "fn product<I>(iter: I) -> Option<T> where\160\160\160\160I: Iterator<Item = Option<U>>,\160"]
    ,Div ("",[],[])
     [Para [Str "Takes",Space,Str "each",Space,Str "element",Space,Str "in",Space,Str "the",Space,Code ("",[],[]) "Iterator",Str ":",Space,Str "if",Space,Str "it",Space,Str "is",Space,Str "a",Space,Code ("",[],[]) "None",Str ",",Space,Str "no",Space,Str "further",SoftBreak,Str "elements",Space,Str "are",Space,Str "taken,",Space,Str "and",Space,Str "the",Space,Code ("",[],[]) "None",Space,Str "is",Space,Str "returned.",Space,Str "Should",Space,Str "no",Space,Code ("",[],[]) "None",Space,Str "occur,",SoftBreak,Str "the",Space,Str "product",Space,Str "of",Space,Str "all",Space,Str "elements",Space,Str "is",Space,Str "returned."]]]
   ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<T> StructuralEq for Option<T>"]
   ,Div ("",[],[])
    []
   ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<T> StructuralPartialEq for Option<T>"]
   ,Div ("",[],[])
    []
   ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<T, U> Sum<Option<U>> for Option<T> where\160\160\160\160T: Sum<U>,\160"]
   ,Div ("",[],[])
    [Header 3 ("",[],[]) [Code ("",[],[]) "fn sum<I>(iter: I) -> Option<T> where\160\160\160\160I: Iterator<Item = Option<U>>,\160"]
    ,Div ("",[],[])
     [Para [Str "Takes",Space,Str "each",Space,Str "element",Space,Str "in",Space,Str "the",Space,Code ("",[],[]) "Iterator",Str ":",Space,Str "if",Space,Str "it",Space,Str "is",Space,Str "a",Space,Code ("",[],[]) "None",Str ",",Space,Str "no",Space,Str "further",SoftBreak,Str "elements",Space,Str "are",Space,Str "taken,",Space,Str "and",Space,Str "the",Space,Code ("",[],[]) "None",Space,Str "is",Space,Str "returned.",Space,Str "Should",Space,Str "no",Space,Code ("",[],[]) "None",Space,Str "occur,",SoftBreak,Str "the",Space,Str "sum",Space,Str "of",Space,Str "all",Space,Str "elements",Space,Str "is",Space,Str "returned."]
     ,Para [Str "This",Space,Str "sums",Space,Str "up",Space,Str "the",Space,Str "position",Space,Str "of",Space,Str "the",Space,Str "character",Space,Str "'a'",Space,Str "in",Space,Str "a",Space,Str "vector",Space,Str "of",Space,Str "strings,",SoftBreak,Str "if",Space,Str "a",Space,Str "word",Space,Str "did",Space,Str "not",Space,Str "have",Space,Str "the",Space,Str "character",Space,Str "'a'",Space,Str "the",Space,Str "operation",Space,Str "returns",Space,Code ("",[],[]) "None",Str ":"]
     ,Div ("",[],[])
      [Para [Str "#+BEGIN_SRC rust \nlet words = vec![\"have\", \"a\", \"great\", \"day\"];\nlet total: Option<usize> = words.iter().map(|w| w.find('a')).sum();\nassert_eq!(total, Some(5));\n#+END_SRC"]]]]
   ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<T> Try for Option<T>"]
   ,Div ("",[],[])
    [Header 3 ("",[],[]) [Code ("Ok.t",[],[]) "type Ok = T"]
    ,Div ("",[],[])
     [Div ("",[],[])
      [Plain [Space,Str "This",Space,Str "is",Space,Str "a",Space,Str "nightly-only",Space,Str "experimental",Space,Str "API.",Space,Str "(",Code ("",[],[]) "try_trait",Str "\160",Span ("",[],[]) [Str "#42327"],Str ")"]]]
    ,Div ("",[],[])
     [Para [Str "The",Space,Str "type",Space,Str "of",Space,Str "this",Space,Str "value",Space,Str "when",Space,Str "viewed",Space,Str "as",Space,Str "successful."]]
    ,Header 3 ("",[],[]) [Code ("Error.t",[],[]) "type Error = NoneError"]
    ,Div ("",[],[])
     [Div ("",[],[])
      [Plain [Space,Str "This",Space,Str "is",Space,Str "a",Space,Str "nightly-only",Space,Str "experimental",Space,Str "API.",Space,Str "(",Code ("",[],[]) "try_trait",Str "\160",Span ("",[],[]) [Str "#42327"],Str ")"]]]
    ,Div ("",[],[])
     [Para [Str "The",Space,Str "type",Space,Str "of",Space,Str "this",Space,Str "value",Space,Str "when",Space,Str "viewed",Space,Str "as",Space,Str "failed."]]
    ,Plain [Code ("into_result.v",[],[]) "fn into_result(self) -> Result<T, NoneError>",Span ("",[],[]) [Str " "]]
    ,Div ("",[],[])
     [Div ("",[],[])
      [Plain [Space,Str "This",Space,Str "is",Space,Str "a",Space,Str "nightly-only",Space,Str "experimental",Space,Str "API.",Space,Str "(",Code ("",[],[]) "try_trait",Str "\160",Span ("",[],[]) [Str "#42327"],Str ")"]]]
    ,Div ("",[],[])
     [Para [Str "Applies",Space,Str "the",Space,Str "\"?\"",Space,Str "operator.",Space,Str "A",Space,Str "return",Space,Str "of",Space,Code ("",[],[]) "Ok(t)",Space,Str "means",Space,Str "that",Space,Str "the",Space,Str "execution",Space,Str "should",Space,Str "continue",Space,Str "normally,",Space,Str "and",Space,Str "the",Space,Str "result",Space,Str "of",Space,Code ("",[],[]) "?",Space,Str "is",Space,Str "the",Space,Str "value",Space,Code ("",[],[]) "t",Str ".",Space,Str "A",Space,Str "return",Space,Str "of",Space,Code ("",[],[]) "Err(e)",Space,Str "means",Space,Str "that",Space,Str "execution",Space,Str "should",Space,Str "branch",Space,Str "to",Space,Str "the",Space,Str "innermost",Space,Str "enclosing",Space,Code ("",[],[]) "catch",Str ",",Space,Str "or",Space,Str "return",Space,Str "from",Space,Str "the",Space,Str "function.",Space,Span ("",[],[]) [Str "Read",Space,Str "more"]]]
    ,Plain [Code ("from_ok.v",[],[]) "fn from_ok(v: T) -> Option<T>",Span ("",[],[]) [Str " "]]
    ,Div ("",[],[])
     [Div ("",[],[])
      [Plain [Space,Str "This",Space,Str "is",Space,Str "a",Space,Str "nightly-only",Space,Str "experimental",Space,Str "API.",Space,Str "(",Code ("",[],[]) "try_trait",Str "\160",Span ("",[],[]) [Str "#42327"],Str ")"]]]
    ,Div ("",[],[])
     [Para [Str "Wrap",Space,Str "an",Space,Str "OK",Space,Str "value",Space,Str "to",Space,Str "construct",Space,Str "the",Space,Str "composite",Space,Str "result.",Space,Str "For",Space,Str "example,",Space,Code ("",[],[]) "Result::Ok(x)",Space,Str "and",Space,Code ("",[],[]) "Result::from_ok(x)",Space,Str "are",Space,Str "equivalent.",Space,Span ("",[],[]) [Str "Read",Space,Str "more"]]]
    ,Plain [Code ("from_error.v",[],[]) "fn from_error(NoneError) -> Option<T>",Span ("",[],[]) [Str " "]]
    ,Div ("",[],[])
     [Div ("",[],[])
      [Plain [Space,Str "This",Space,Str "is",Space,Str "a",Space,Str "nightly-only",Space,Str "experimental",Space,Str "API.",Space,Str "(",Code ("",[],[]) "try_trait",Str "\160",Span ("",[],[]) [Str "#42327"],Str ")"]]]
    ,Div ("",[],[])
     [Para [Str "Wrap",Space,Str "an",Space,Str "error",Space,Str "value",Space,Str "to",Space,Str "construct",Space,Str "the",Space,Str "composite",Space,Str "result.",Space,Str "For",Space,Str "example,",Space,Code ("",[],[]) "Result::Err(x)",Space,Str "and",Space,Code ("",[],[]) "Result::from_error(x)",Space,Str "are",Space,Str "equivalent.",Space,Span ("",[],[]) [Str "Read",Space,Str "more"]]]]]
  ,Header 1 ("",[],[]) [Str "Auto"]
  ,Div ("",[],[])
   [Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<T> RefUnwindSafe for Option<T> where\160\160\160\160T: RefUnwindSafe,\160"]
   ,Div ("",[],[])
    []
   ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<T> Send for Option<T> where\160\160\160\160T: Send,\160"]
   ,Div ("",[],[])
    []
   ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<T> Sync for Option<T> where\160\160\160\160T: Sync,\160"]
   ,Div ("",[],[])
    []
   ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<T> Unpin for Option<T> where\160\160\160\160T: Unpin,\160"]
   ,Div ("",[],[])
    []
   ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<T> UnwindSafe for Option<T> where\160\160\160\160T: UnwindSafe,\160"]
   ,Div ("",[],[])
    []]
  ,Header 1 ("",[],[]) [Str "Blanket"]
  ,Div ("",[],[])
   [Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<T> Any for T where\160\160\160\160T: 'static + ?Sized,\160"]
   ,Div ("",[],[])
    [Plain [Code ("type_id.v",[],[]) "fn type_id(&self) -> TypeId",Span ("",[],[]) [Str " "]]
    ,Div ("",[],[])
     [Para [Str "Gets",Space,Str "the",Space,Code ("",[],[]) "TypeId",Space,Str "of",Space,Code ("",[],[]) "self",Str ".",Space,Span ("",[],[]) [Str "Read",Space,Str "more"]]]]
   ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<T> Borrow<T> for T where\160\160\160\160T: ?Sized,\160"]
   ,Div ("",[],[])
    [Plain [Code ("borrow.v",[],[]) "fn borrow(&self) -> &T",Span ("",[],[]) [Str " "]]
    ,Div ("",[],[])
     [Para [Str "Immutably",Space,Str "borrows",Space,Str "from",Space,Str "an",Space,Str "owned",Space,Str "value.",Space,Span ("",[],[]) [Str "Read",Space,Str "more"]]]]
   ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<T> BorrowMut<T> for T where\160\160\160\160T: ?Sized,\160"]
   ,Div ("",[],[])
    [Plain [Code ("borrow_mut.v",[],[]) "fn borrow_mut(&mut self) -> &mut T",Span ("",[],[]) [Str " "]]
    ,Div ("",[],[])
     [Para [Str "Mutably",Space,Str "borrows",Space,Str "from",Space,Str "an",Space,Str "owned",Space,Str "value.",Space,Span ("",[],[]) [Str "Read",Space,Str "more"]]]]
   ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<T> From<!> for T"]
   ,Div ("",[],[])
    [Plain [Code ("from.v-4",[],[]) "fn from(t: !) -> T",Span ("",[],[]) [Str " "]]
    ,Div ("",[],[])
     [Para [Str "Performs",Space,Str "the",Space,Str "conversion."]]]
   ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<T> From<T> for T"]
   ,Div ("",[],[])
    [Plain [Code ("from.v-3",[],[]) "fn from(t: T) -> T",Span ("",[],[]) [Str " "]]
    ,Div ("",[],[])
     [Para [Str "Performs",Space,Str "the",Space,Str "conversion."]]]
   ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<T, U> Into<U> for T where\160\160\160\160U: From<T>,\160"]
   ,Div ("",[],[])
    [Plain [Code ("into.v",[],[]) "fn into(self) -> U",Span ("",[],[]) [Str " "]]
    ,Div ("",[],[])
     [Para [Str "Performs",Space,Str "the",Space,Str "conversion."]]]
   ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<I> IntoIterator for I where\160\160\160\160I: Iterator,\160"]
   ,Div ("",[],[])
    [Header 3 ("",[],[]) [Code ("Item.t-3",[],[]) "type Item = <I as Iterator>::Item"]
    ,Div ("",[],[])
     [Para [Str "The",Space,Str "type",Space,Str "of",Space,Str "the",Space,Str "elements",Space,Str "being",Space,Str "iterated",Space,Str "over."]]
    ,Header 3 ("",[],[]) [Code ("IntoIter.t-3",[],[]) "type IntoIter = I"]
    ,Div ("",[],[])
     [Para [Str "Which",Space,Str "kind",Space,Str "of",Space,Str "iterator",Space,Str "are",Space,Str "we",Space,Str "turning",Space,Str "this",Space,Str "into?"]]
    ,Plain [Code ("into_iter.v-3",[],[]) "fn into_iter(self) -> I",Span ("",[],[]) [Str " "]]
    ,Div ("",[],[])
     [Para [Str "Creates",Space,Str "an",Space,Str "iterator",Space,Str "from",Space,Str "a",Space,Str "value.",Space,Span ("",[],[]) [Str "Read",Space,Str "more"]]]]
   ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<T> ToOwned for T where\160\160\160\160T: Clone,\160"]
   ,Div ("",[],[])
    [Header 3 ("",[],[]) [Code ("Owned.t",[],[]) "type Owned = T"]
    ,Div ("",[],[])
     [Para [Str "The",Space,Str "resulting",Space,Str "type",Space,Str "after",Space,Str "obtaining",Space,Str "ownership."]]
    ,Plain [Code ("to_owned.v",[],[]) "fn to_owned(&self) -> T",Span ("",[],[]) [Str " "]]
    ,Div ("",[],[])
     [Para [Str "Creates",Space,Str "owned",Space,Str "data",Space,Str "from",Space,Str "borrowed",Space,Str "data,",Space,Str "usually",Space,Str "by",Space,Str "cloning.",Space,Span ("",[],[]) [Str "Read",Space,Str "more"]]]
    ,Plain [Code ("clone_into.v",[],[]) "fn clone_into(&self, target: &mut T)",Span ("",[],[]) [Str " "]]
    ,Div ("",[],[])
     [Div ("",[],[])
      [Plain [Space,Str "This",Space,Str "is",Space,Str "a",Space,Str "nightly-only",Space,Str "experimental",Space,Str "API.",Space,Str "(",Code ("",[],[]) "toowned_clone_into",Str "\160",Span ("",[],[]) [Str "#41263"],Str ")"]
      ,Para [Str "recently",Space,Str "added"]]]
    ,Div ("",[],[])
     [Para [Str "Uses",Space,Str "borrowed",Space,Str "data",Space,Str "to",Space,Str "replace",Space,Str "owned",Space,Str "data,",Space,Str "usually",Space,Str "by",Space,Str "cloning.",Space,Span ("",[],[]) [Str "Read",Space,Str "more"]]]]
   ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<T, U> TryFrom<U> for T where\160\160\160\160U: Into<T>,\160"]
   ,Div ("",[],[])
    [Header 3 ("",[],[]) [Code ("Error.t-1",[],[]) "type Error = Infallible"]
    ,Div ("",[],[])
     [Para [Str "The",Space,Str "type",Space,Str "returned",Space,Str "in",Space,Str "the",Space,Str "event",Space,Str "of",Space,Str "a",Space,Str "conversion",Space,Str "error."]]
    ,Plain [Code ("try_from.v",[],[]) "fn try_from(value: U) -> Result<T, <T as TryFrom<U>>::Error>",Span ("",[],[]) [Str " "]]
    ,Div ("",[],[])
     [Para [Str "Performs",Space,Str "the",Space,Str "conversion."]]]
   ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<T, U> TryInto<U> for T where\160\160\160\160U: TryFrom<T>,\160"]
   ,Div ("",[],[])
    [Header 3 ("",[],[]) [Code ("Error.t-2",[],[]) "type Error = <U as TryFrom<T>>::Error"]
    ,Div ("",[],[])
     [Para [Str "The",Space,Str "type",Space,Str "returned",Space,Str "in",Space,Str "the",Space,Str "event",Space,Str "of",Space,Str "a",Space,Str "conversion",Space,Str "error."]]
    ,Plain [Code ("try_into.v",[],[]) "fn try_into(self) -> Result<U, <U as TryFrom<T>>::Error>",Span ("",[],[]) [Str " "]]
    ,Div ("",[],[])
     [Para [Str "Performs",Space,Str "the",Space,Str "conversion."]]]]]
 ,Div ("",[],[])
  []
 ,Div ("",[],[])
  []]]
